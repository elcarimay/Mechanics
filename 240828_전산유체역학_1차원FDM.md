## **1차원 유동의 지배방정식과 수치해석 - 경계치 문제**

$u = f(x)$  
  
$\frac{d^{2}u}{dx^{2}}=-x^{2}$ **(2계 선형 상미분 방정식)**  
   
$0\le x\le1$  
   
$u(0) = 0, u(1) = 0$  
  
**Exact Sol:** $u = 2 + x^{2} -2\cosh{x}+\left(\frac{2\cosh{1}-3}{\sinh{1}}\right)\sinh{x}\ $  
import numpy as np
import matplotlib.pyplot as plt
x = np.linspace(0,1,5)
x2 = np.linspace(0,1,100)
def exact(x):
    return 2 + x**2 - 2*np.cosh(x) +(2*np.cosh(1)-3)/np.sinh(1)*np.sinh(x)
u = exact(x)
u2 = exact(x2)
plt.figure(figsize=(6,4))
plt.plot(x,u,'-s', label='Points: 5')
plt.plot(x2,u2, label='Points: 100')
plt.xlabel('$x$')
plt.ylabel('$u$')
plt.legend()
plt.grid()

### ※ 미분방정식을 풀때 위의 정의역을 미소 구간으로 나누고 각 $x$지점을 변수로 놓고 계산함.

$u_{0}$&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;
$u_{1}$&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
$u_{2}$&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
$u_{3}$&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
$u_{4}$

## **차분화(discretization)**  

$\Delta{x}=0.25$  

$\frac{u_{0}-2u_{1}+u_{2}}{\Delta{x}^{2}}-u_{1}=-x^{2}_{1}$  
   
$\frac{u_{1}-2u_{2}+u_{3}}{\Delta{x}^{2}}-u_{2}=-x^{2}_{2}$  
   
$\frac{u_{2}-2u_{3}+u_{4}}{\Delta{x}^{2}}-u_{3}=-x^{2}_{3}$  
   
$x_{1}=0.25,　x_{2}=0.50,　x_{3}=0.75$  
   
### 미지수가 3개인데 방정식이 2개이므로 경계조건이 필요  
   
$u_{0}=0,　u_{4}=0$  
   
$\left(\begin{matrix}-\left(2+\Delta{x}^{2}\right)&1&0\\1&-\left(2+\Delta{x}^{2}\right)&1\\0&1&-\left(2+\Delta{x}^{2}\right)\\\end{matrix}\right)
\left(\begin{matrix}u_1\\u_2\\u_3\\\end{matrix}\right)=
\left(\begin{matrix}-x^2_1\Delta{x}^2\\-x^2_2\Delta{x}^2\\-x^2_3\Delta{x}^2\\\end{matrix}\right)$   
  
$\left(\begin{matrix}-2.0625&1&0\\1&-2.0625&1\\0&1&-2.0625\\\end{matrix}\right)
\left(\begin{matrix}u_1\\u_2\\u_3\\\end{matrix}\right)=
\left(\begin{matrix}-0.0039\\-0.0173\\-0.0462\\\end{matrix}\right)$  
   
$u_1=0.0171,u_2=0.0314,u_3=0.0323$

dx = 0.25
x = np.linspace(0,1,5)
mat = np.asfarray([[-(2+dx**2),1,0],[1,-(2+dx**2),1],[0,1,-(2+dx**2)]])
y = np.asfarray([[-x[1]**2*dx**2],[-x[2]**2*dx**2],[-x[3]**2*dx**2]])
mat_inv = np.linalg.inv(mat)
sol = np.matmul(mat_inv,y)
# sol = linalg.solve(mat, y)

plt.figure(figsize=(6,4))
plt.plot(x,np.r_[np.asfarray([[0]]),sol,np.asfarray([[0]])],'-s',label='Discretization')
plt.plot(x2,u2,label='Exaxt. Sol.')
plt.xlabel('$x$')
plt.ylabel('$u$')
plt.legend()
plt.grid()

# **1차원 유동의 지배방정식과 수치해석 - 초기치문제**
  
$u = f(t, x)$  
   
$\frac{\partial{u}}{\partial{t}}=\frac{\partial^2{u}}{\partial{x}^2}$ **(2계 선형 편미분 방정식)**  
   
$0\le x\le1,t\ge0$  
  
$u(t,0) = 0, u(t,1) = 0$ ← 경계조건   
   
$u(0,x) = \sin{\pi{x}}$ ← 초기조건   
 
### **※ 시간미분항을 어떻게 이산화하는냐에 따라 양해법(Explicit Method)과 음해법(Implicit Method)로 나눔.**

## **1. Explicit Method: 우변항을 현재값으로 차분, 현재값으로 미래값을 계산**

![image.png](attachment:2d94348b-026d-46b3-8e94-dbb989fbaa72.png)

$\frac{\partial{u}}{\partial{t}}\cong\frac{u^1_1-u^0_1}{\Delta{t}}$,
$\frac{\partial^2{u}}{\partial^2{x}}\cong\frac{u^0_0-2u^0_1+u^0_2}{\Delta{t^2}}$  
   
$\frac{u^1_1-u^0_1}{\Delta{t}}=\frac{u^0_0-2u^0_1+u^0_2}{\Delta{t^2}}$  
   
$\frac{u^1_2-u^0_2}{\Delta{t}}=\frac{u^0_1-2u^0_2+u^0_3}{\Delta{t^2}}$  
   
$\frac{u^1_3-u^0_3}{\Delta{t}}=\frac{u^0_2-2u^0_3+u^0_4}{\Delta{t^2}}$  
   
$u^1_i=u^0_1+\alpha\left(u^0_{i-1}-2u^0_i+u^0_{i+1}\right)$&emsp;&emsp;$\left(i=1,2,3\right)$  
   
$\alpha=\frac{\Delta{t}}{\Delta{x}^2}$  
   
$\Delta{x}=0.25, \Delta{t}=0.01$&nbsp;이라고 하면,    
   
$\alpha=\frac{0.01}{{0.25}^2}=0.16$

import numpy as np
import matplotlib.pyplot as plt


def Exact(t, x):
    Y = np.zeros((len(t),len(x)))
    for c in range(len(t)):
        for r in range(len(x)):
            Y[c,r] = np.sin(np.pi*x[r])*np.exp(-np.pi**2*t[c])
    return Y

def Explicit(dx, x_max, dt, t_max, legend_plot = 1):
    x, t = np.arange(0, x_max+dx, dx).round(3), np.arange(0,t_max+dt, dt).round(3)
    bc = [0,0]
    initial = np.sin(np.pi*x)
    T = np.zeros((len(t),len(x)))
    T[:,0], T[:,-1], T[0,:] = bc[0], bc[1], initial
    # T[0,:]=0;T[:,-1]=1
    T.round(3)
    alpha = dt/dx**2
    for c in range(1,len(T)):
        for r in range(1,len(x)-1):
            T[c,r] = T[c-1,r]+alpha*(T[c-1,r-1]-2*T[c-1,r]+T[c-1,r+1])
    R, B, G = np.linspace(1,0,len(T)), np.linspace(0,1,len(T)), 0
    ext_sol = Exact(t,x)
    plt.figure(figsize=(6,4))
    for i in range(len(t)):
        plt.plot(x,ext_sol[i], color = [R[i], G, B[i]])
    for i in range(len(T)):
        plt.plot(x,T[i], 's',color = [R[i], G, B[i]])
    plt.title('$Points=%d,dt=%1.4f,dx=%1.3f$,Line=Exact.Sol.,Ret.:Cal.Value'%(len(x),dt,dx))
    plt.xlabel('distance [m]')
    plt.ylabel('Temperature [degree C]')
    if(legend_plot):
        plt.legend([f't = {value} s' for value in t])
    plt.grid()

### **1) 정의역을 5개로 분할**

dx, x_max, dt, t_max = 0.25, 1, 0.025, 0.1
Explicit(dx, x_max, dt, t_max)

### **2) 정의역을 11개로 분할**

dx, x_max, dt, t_max = 0.1, 1, 0.0056, 1
Explicit(dx, x_max, dt, t_max, 0)

### **Stability: &nbsp;$\Delta{t}$&nbsp;증가시 발산(diverge)함.**

dx, x_max, dt, t_max = 0.1, 1, 0.0058, 1
Explicit(dx, x_max, dt, t_max, 0)

## **2. Implicit Method: 우변항을 미래값으로 차분**

$\frac{\partial{u}}{\partial{t}}\cong\frac{u^1_1-u^0_1}{\Delta{t}}$,
$\frac{\partial^2{u}}{\partial^2{x}}\cong\frac{u^1_0-2u^1_1+u^1_2}{\Delta{t^2}}$  
 
$\alpha=\frac{\Delta{t}}{\Delta{x}^2}$&nbsp;을 사용하여 정리하면,    
 
$\left(1+2\alpha\right)u^1_1-\alpha{u^1_2}=u^0_1$  
   
$-\alpha{u^1_1}+\left(1+2\alpha\right)u^1_2-\alpha{u^1_3}=u^0_2$  
   
$-\alpha{u^1_2}+\left(1+2\alpha\right)u^1_3=u^0_3+\alpha$  
   
$\left(\begin{matrix}1+2\alpha&-\alpha&0\\-\alpha&1+2\alpha&-\alpha\\0&-\alpha&1+2\alpha\\\end{matrix}\right)
\left(\begin{matrix}u^1_1\\u^1_2\\u^1_3\\\end{matrix}\right)=
\left(\begin{matrix}u^0_1\\u^0_2\\u^0_3+\alpha\\\end{matrix}\right)$  

def Implicit(dx, x_max, dt, t_max, legend_plot = 1):
    x, t = np.arange(0, x_max+dx, dx).round(3), np.arange(0,t_max+dt, dt).round(3)
    bc = [0,0]; lx, lt = len(x), len(t)
    initial = np.sin(np.pi*x)
    T = np.zeros((len(t),len(x)))
    T[:,0], T[:,-1], T[0,:] = bc[0], bc[1], initial
    alpha = dt/dx**2
    mat = np.diag([1+2*alpha]*(lx-2),0) + np.diag([-alpha]*(lx-3),-1) + np.diag([-alpha]*(lx-3),1)
    for c in range(1,len(T)):
        b = T[c-1,1:-1]
        b[0], b[-1] = b[0] + alpha*T[c,1], b[-1] + alpha*T[c,-1]
        T[c,1:-1] = np.linalg.solve(mat, b)
    T.round(3)
    R, B, G = np.linspace(1,0,len(T)), np.linspace(0,1,len(T)), 0
    ext_sol = Exact(t,x)
    plt.figure(figsize=(6,4))
    for i in range(len(t)):
        plt.plot(x,ext_sol[i], color = [R[i], G, B[i]])
    for i in range(len(T)):
        plt.plot(x,T[i], 's',color = [R[i], G, B[i]])
    plt.title('$Points=%d,dt=%1.4f,dx=%1.3f$,Line=Exact.Sol.,Ret.:Cal.Value'%(len(x),dt,dx))
    plt.xlabel('distance [m]')
    plt.ylabel('Temperature [degree C]')
    if(legend_plot):
        plt.legend([f't = {value} s' for value in t])
    plt.grid()

### **1) 정의역을 5개로 분할**

dx, x_max, dt, t_max = 0.25, 1, 0.025, 0.1
Implicit(dx, x_max, dt, t_max)

### **2) 정의역을 11개로 분할**

dx, x_max, dt, t_max = 0.1, 1, 0.0056, 1
Implicit(dx, x_max, dt, t_max, 0)

### **Stability: 양해법에 비하여 $\Delta{t}$가 상대적으로 더 커도 수렴(Convergence)이 잘됨.**

dx, x_max, dt, t_max = 0.1, 1, 0.056, 1
Implicit(dx, x_max, dt, t_max, 0)

### **Implicit는 Explit에 비하여 $\Delta{x}$를 많이 줄여야 하는 경우 시간적으로 절약이 됨.**  
   
### **Explit는 Exact. Sol.에 근접하여 구하지만 계산량이 많음.**    
   
### **따라서, 정상상태의 해만 구하는 경우  Implicit가 더 유리함.**

# **3. Crank Nicholson Mothod**

def Crank_Nicholson(dx, x_max, dt, t_max, legend_plot = 1):
    x, t = np.arange(0, x_max+dx, dx).round(3), np.arange(0,t_max+dt, dt).round(3)
    bc = [0,0]; lx, lt = len(x), len(t)
    initial = np.sin(np.pi*x)
    T = np.zeros((len(t),len(x)))
    T[:,0], T[0,:], T[:,-1] = bc[0], initial, bc[1]
    alpha = dt/dx**2
    A = np.diag([2*(1+alpha)]*(lx-2),0) + np.diag([-alpha]*(lx-3),-1) + np.diag([-alpha]*(lx-3),1)
    B = np.diag([2*(1-alpha)]*(lx-2),0) + np.diag([alpha]*(lx-3),-1) + np.diag([alpha]*(lx-3),1)
    for c in range(1,len(T)):
        b = T[c-1,1:-1]
        b = np.dot(B,b)
        b[0], b[-1] = b[0] + alpha*(T[c-1,0]+T[c,0]), b[-1] + alpha*(T[c-1,-1]+T[c,-1])
        T[c,1:-1] = np.linalg.solve(A, b)
    T.round(3)
    R, B, G = np.linspace(1,0,len(T)), np.linspace(0,1,len(T)), 0
    ext_sol = Exact(t,x)
    plt.figure(figsize=(6,4))
    for i in range(len(t)):
        plt.plot(x,ext_sol[i], color = [R[i], G, B[i]])
    for i in range(len(T)):
        plt.plot(x,T[i], 's',color = [R[i], G, B[i]])
    plt.title('$Points=%d,dt=%1.4f,dx=%1.3f$,Line=Exact.Sol.,Ret.:Cal.Value'%(len(x),dt,dx))
    plt.xlabel('distance [m]')
    plt.ylabel('Temperature [degree C]')
    if(legend_plot):
        plt.legend([f't = {value} s' for value in t])
    plt.grid()

### **1) 정의역을 5개로 분할**

dx, x_max, dt, t_max = 0.25, 1, 0.025, 0.1
Crank_Nicholson(dx, x_max, dt, t_max)

### **2) 정의역을 11개로 분할**

dx, x_max, dt, t_max = 0.1, 1, 0.0056, 1
Crank_Nicholson(dx, x_max, dt, t_max,0)

## **Animation**|

# Simulating
counter = 0
dx, x_max, dt, t_max = 0.025, 1, 0.025, 1
x, t = np.arange(0, x_max+dx, dx).round(3), np.arange(0,t_max+dt, dt).round(3)
bc = [0,0]; lx, lt = len(x), len(t)
initial = np.sin(np.pi*x)
T = np.zeros((len(t),len(x)))
T[:,0], T[0,:], T[:,-1] = bc[0], initial, bc[1]

# %matplotlib notebook
import matplotlib.animation

plt.rcParams["animation.html"] = "jshtml"
plt.rcParams['figure.dpi'] = 150  
plt.ioff()

# Visualizing with a plot
fig, ax = plt.subplots(1, figsize=(10,3))
# ax.set_ylim([0.4, 0.6])

pcm = ax.pcolormesh([T[0]], cmap=plt.cm.jet, vmin=0, vmax=1)
plt.colorbar(pcm, ax=ax)

alpha = dt/dx**2
A = np.diag([2*(1+alpha)]*(lx-2),0) + np.diag([-alpha]*(lx-3),-1) + np.diag([-alpha]*(lx-3),1)
B = np.diag([2*(1-alpha)]*(lx-2),0) + np.diag([alpha]*(lx-3),-1) + np.diag([alpha]*(lx-3),1)
for c in range(1,len(T)):
    b = T[c-1,1:-1]
    b = np.dot(B,b)
    b[0], b[-1] = b[0] + alpha*(T[c-1,0]+T[c,0]), b[-1] + alpha*(T[c-1,-1]+T[c,-1])
    T[c,1:-1] = np.linalg.solve(A, b)
T.round(3)

def animate(t):
    # Updating the plot
    pcm.set_array([T[t]])
    ax.set_title("Distribution at t: {:.3f} [s], Avg. Temp.: {:.2f} Celcius".format(dt*(t), np.average(T[t])))

ani = matplotlib.animation.FuncAnimation(fig, animate, frames=40, interval=100, blit=True)
from IPython.display import HTML
HTML(ani.to_jshtml())

